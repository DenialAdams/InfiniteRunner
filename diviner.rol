static GAME_OVER: bool;
static PLAYER_POSITION: Position;
static JUMP_SPEED: f64;
static JUMP_STATE: JumpState;
static RNG: u64;
static SCORE_BUF: [u8; 10];
static TIME_DEAD: u64;

static TILES: [Tile; 1600];

const CAMERAS: [Position; 16] = [
   // center of the first square, etc
   Position { x: 80.0, y: 80.0 },
   Position { x: 240.0, y: 80.0 },
   Position { x: 400.0, y: 80.0 },
   Position { x: 560.0, y: 80.0 },
   Position { x: 80.0, y: 240.0 },
   Position { x: 240.0, y: 240.0 },
   Position { x: 400.0, y: 240.0 },
   Position { x: 560.0, y: 240.0 },
   Position { x: 80.0, y: 400.0 },
   Position { x: 240.0, y: 400.0 },
   Position { x: 400.0, y: 400.0 },
   Position { x: 560.0, y: 400.0 },
   Position { x: 80.0, y: 560.0 },
   Position { x: 240.0, y: 560.0 },
   Position { x: 400.0, y: 560.0 },
   Position { x: 560.0, y: 560.0 },
];

struct Position {
   x: f64,
   y: f64,
}


struct Tile {
   solid: bool,
}

enum JumpState {
   Standing,
   Jumping,
   Falling,
}

proc dist(position_1: Position, position_2: Position) -> f64 {
   let x_diff = position_1.x - position_2.x;
   let y_diff = position_1.y - position_2.y;
   return sqrt((x_diff * x_diff) + (y_diff * y_diff));
}

proc rand() -> u64 {
   RNG = RNG ^ (RNG << 13);
   RNG = RNG ^ (RNG >> 7);
   RNG = RNG ^ (RNG << 17);
   return RNG;
}

proc rand_range(rand_min: u64, rand_max: u64) -> u64 {
   return rand() % (rand_max + 1 - rand_min) + rand_min;
}

proc one_in(x: u64) -> bool {
   return rand_range(0, x - 1) == 0;
}

proc rectangles_collide(x1: f64, y1: f64, width1: f64, height1: f64, x2: f64, y2: f64, width2: f64, height2: f64) -> bool {
   return
      (x1 < x2 + width2) &
      (x1 + width1 > x2) &
      (y1 < y2 + height2) &
      (height1 + y1 > y2);
}

proc reset_game() {
   GAME_OVER = false;
   TIME_DEAD = 0;
   PLAYER_POSITION.x = 64.0;
   PLAYER_POSITION.y = 64.0;
   JUMP_SPEED = 0.0;
   JUMP_STATE = JumpState::Standing;
   GHOST_IS_PRESENT = false;
   TIME_ALIVE = 0;

   let len: usize = 1600;
   for i in 0..len {
      let col = (i % 40);
      let row = (i / 40);
      if (col % 10 == 0 or col % 10 == 9) or (row % 10 == 0 or row % 10 == 9) {
         TILES[i].solid = true;
      } else {
         TILES[i].solid = false;
      }
   }

   carve_path();
}

proc carve_path() {
   let starting_cell = rand_range(0, 3);

   PLAYER_POSITION.x = (160.0 * starting_cell truncate f64) + 64.0;

   let current_cell = starting_cell truncate i32;

   // 00 01 02 03
   // 04 05 06 07
   // 08 09 10 11
   // 12 13 14 15

   loop {
      let where_to_go = rand_range(1, 5);

      let direction: i32 = 0;
      if where_to_go == 1 or where_to_go == 2 {
         // left
         if (current_cell % 4 == 0) {
            direction = 4;
         } else {
            direction = -1;
         }
      } else if where_to_go == 3 or where_to_go == 4 {
         // right
         if (current_cell % 4 == 3) {
            direction = 4;
         } else {
            direction = 1;
         }
      } else if where_to_go == 5 {
         // down
         direction = 4;
      }

      if direction == 4 and current_cell >= 12 {
         // path is done
         break;
      }

      let current_row = current_cell / 4;
      let current_col = current_cell % 4;

      if direction == -1 {
         // remove the left wall
         let start_index = ((current_row * 400) + current_col * 10) transmute usize;
         TILES[start_index + 40].solid = false;
         TILES[start_index + 80].solid = false;
         TILES[start_index + 120].solid = false;
         TILES[start_index + 160].solid = false;
         TILES[start_index + 200].solid = false;
         TILES[start_index + 240].solid = false;
         TILES[start_index + 280].solid = false;
         TILES[start_index + 320].solid = false;
         TILES[start_index + 39].solid = false;
         TILES[start_index + 79].solid = false;
         TILES[start_index + 119].solid = false;
         TILES[start_index + 159].solid = false;
         TILES[start_index + 199].solid = false;
         TILES[start_index + 239].solid = false;
         TILES[start_index + 279].solid = false;
         TILES[start_index + 319].solid = false;
      } else if direction == 1 {
         let start_index = (((current_row * 400) + current_col * 10) + 9) transmute usize;
         TILES[start_index + 40].solid = false;
         TILES[start_index + 80].solid = false;
         TILES[start_index + 120].solid = false;
         TILES[start_index + 160].solid = false;
         TILES[start_index + 200].solid = false;
         TILES[start_index + 240].solid = false;
         TILES[start_index + 280].solid = false;
         TILES[start_index + 320].solid = false;
         TILES[start_index + 41].solid = false;
         TILES[start_index + 81].solid = false;
         TILES[start_index + 121].solid = false;
         TILES[start_index + 161].solid = false;
         TILES[start_index + 201].solid = false;
         TILES[start_index + 241].solid = false;
         TILES[start_index + 281].solid = false;
         TILES[start_index + 321].solid = false;
      } else if direction == 4 {
         let start_index = (((current_row * 400) + current_col * 10) + 360) transmute usize;
         TILES[start_index + 1].solid = false;
         TILES[start_index + 2].solid = false;
         TILES[start_index + 3].solid = false;
         TILES[start_index + 4].solid = false;
         TILES[start_index + 5].solid = false;
         TILES[start_index + 6].solid = false;
         TILES[start_index + 7].solid = false;
         TILES[start_index + 8].solid = false;
         TILES[start_index + 41].solid = false;
         TILES[start_index + 42].solid = false;
         TILES[start_index + 43].solid = false;
         TILES[start_index + 44].solid = false;
         TILES[start_index + 45].solid = false;
         TILES[start_index + 46].solid = false;
         TILES[start_index + 47].solid = false;
         TILES[start_index + 48].solid = false;
      }

      current_cell = current_cell + direction;
   }
}

proc start() {
   *PALETTE = [16774867, 16361589, 15428463, 8142680];
   RNG = 2;
   reset_game();
}

proc sim(dt: f64) {
   // Handle input
   let jump_pressed = ((*GAMEPADS)[0] & BUTTON_1) > 0;
   if jump_pressed and JUMP_STATE == JumpState::Standing and !GAME_OVER {
      JUMP_STATE = JumpState::Jumping;
      JUMP_SPEED = 10.0;
      tone(300 | (800 << 16), 6, 50, TONE_MODE1);
   } else if (false) and TIME_DEAD >= 5 {
      reset_game();
      return;
   }

   let left_pressed = ((*GAMEPADS)[0] & BUTTON_LEFT) > 0;
   let right_pressed = ((*GAMEPADS)[0] & BUTTON_RIGHT) > 0;

   let go_left = left_pressed & !right_pressed;
   let go_right = right_pressed & !left_pressed;

   let offset: f64 = 0.0;
   if go_left {
      PLAYER_POSITION.x = PLAYER_POSITION.x - (1.0 * dt);
      offset = 16.0;
   } else if go_right {
      PLAYER_POSITION.x = PLAYER_POSITION.x + (1.0 * dt);
      offset = -10.0;
   }

   let len: usize = 1600;
   for i in 0..len {
      if !TILES[i].solid {
         continue;
      }

      let x = ((i % 40) * 16) truncate f64;
      let y = ((i / 40) * 16) truncate f64;
      if rectangles_collide(PLAYER_POSITION.x, PLAYER_POSITION.y, 10.0, 32.0, x, y, 16.0, 16.0) {
         PLAYER_POSITION.x = x + offset;
      }
   }
   
   // Check if colliding with ghost
   if rectangles_collide(PLAYER_POSITION.x, PLAYER_POSITION.y, 10.0, 32.0, GHOST_POSITION.x, GHOST_POSITION.y, GHOST_WIDTH truncate f64, GHOST_HEIGHT truncate f64) {
         maybe_play_game_over_noise();
         GAME_OVER = true;
         return;
   }

   // Do jumping
   {
      if JUMP_STATE == JumpState::Jumping {
         JUMP_SPEED = JUMP_SPEED - (1.0 * dt);
         PLAYER_POSITION.y = PLAYER_POSITION.y - (JUMP_SPEED * dt);
         if (JUMP_SPEED <= 0.0) {
            JUMP_SPEED = 0.0;
            JUMP_STATE = JumpState::Falling;
         }
      } else if JUMP_STATE == JumpState::Falling {
         JUMP_SPEED = JUMP_SPEED + (0.3 * dt);
         PLAYER_POSITION.y = PLAYER_POSITION.y + (JUMP_SPEED * dt);

         for i in 0..len {
            if !TILES[i].solid {
               continue;
            }

            let x = ((i % 40) * 16) truncate f64;
            let y = ((i / 40) * 16) truncate f64;
            if rectangles_collide(PLAYER_POSITION.x, PLAYER_POSITION.y, 10.0, 32.0, x, y, 16.0, 16.0) {
               PLAYER_POSITION.y = y - 32.0;
               JUMP_STATE = JumpState::Standing;
            }
         }
      } else if JUMP_STATE == JumpState::Standing {
         let ontop = false;
         for i in 0..len {
            if !TILES[i].solid {
               continue;
            }

            let x = ((i % 40) * 16) truncate f64;
            let y = ((i / 40) * 16) truncate f64;
            if !rectangles_collide(PLAYER_POSITION.x, PLAYER_POSITION.y - 1.0, 10.0, 32.0, x, y, 16.0, 16.0) {
               JUMP_SPEED = 0.0;
               JUMP_STATE = JumpState::Falling;
            }
         }
      }
   }
}

proc update() {
   update_timers();

   let reset_pressed = ((*GAMEPADS)[0] & BUTTON_2) > 0;
   if reset_pressed {
      reset_game();
   }

   //sim(0.1666);
   //sim(0.1666);
   //sim(0.1666);
   sim(1.0);
   if GAME_OVER {
      game_over();
   }

   {
      if (!GHOST_IS_PRESENT) {
      maybe_spawn_ghost();
      }
      move_ghost();
   }
   //sim(0.3333);
   //sim(0.3333);

   // Draw world
   {
      // Always keep camera centered
      let clens: usize = 16;
      let closest_cam: usize = 0;
      let min_dist: f64 = dist(PLAYER_POSITION, CAMERAS[0]);
      for x in 1..clens {
         let dist = dist(PLAYER_POSITION, CAMERAS[x]);
         if dist < min_dist {
            min_dist = dist;
            closest_cam = x;
         }
      }

      let camera_offset_x: f64 = (CAMERAS[closest_cam].x) - 80.0;
      let camera_offset_y: f64 = (CAMERAS[closest_cam].y) - 80.0;

      // Draw player
      rect((PLAYER_POSITION.x - camera_offset_x) truncate i32, (PLAYER_POSITION.y - camera_offset_y) truncate i32, 10, 32);
      if (GHOST_IS_PRESENT) {
         draw_ghost(camera_offset_x, camera_offset_y);
      }

      let len: usize = 1600;
      for i in 0..len {
         if !TILES[i].solid {
            continue;
         }
         let x = ((i % 40) * 16) truncate f64;
         let y = ((i / 40) * 16) truncate f64;
         rect((x - camera_offset_x) truncate i32, (y - camera_offset_y) truncate i32, 16, 16);
      }
   }

   //trace(int_to_string(PLAYER_POSITION.y truncate u32, &SCORE_BUF));

   // Draw UI
   {
      //text("SCORE: ", 2, 2);
      //text(int_to_string((PLAYER_POSITION.x / 10.0) truncate u32, &SCORE_BUF), 47, 2);
   }
}


// Ghost code
static TIME_ALIVE: u64;

const GHOST_SPAWN_TIME: u64 = 60*5; // 5 seconds timer for ghost. TODO update.
static GHOST_IS_PRESENT: bool;
static GHOST_POSITION: Position;
const GHOST_HEIGHT: u32 = 30;
const GHOST_WIDTH: u32 = 30;
const GHOST_SPEED: u64 = 1;
const DEFAULT_VOLUME: u32 = 50;


proc update_timers() {
   if GAME_OVER {
      TIME_DEAD = TIME_DEAD + 1;
   } else {
      TIME_ALIVE = TIME_ALIVE + 1;
   }
}

proc maybe_spawn_ghost() {
   if (TIME_ALIVE > GHOST_SPAWN_TIME) {
      GHOST_IS_PRESENT = true;
      // TODO: spawn in opposite corner of player, instead of top left.
      GHOST_POSITION.x = 0.0;
      GHOST_POSITION.y = 0.0;
   }
}

// Caller should check if GHOST_IS_PRESENT before moving.
proc move_ghost() {
   // if player x > ghost x, ghost x++
   // if player x < ghost x, ghost x--
   if (PLAYER_POSITION.x >= GHOST_POSITION.x) {
      GHOST_POSITION.x = GHOST_POSITION.x+1.0;
   }
   else {
      GHOST_POSITION.x = GHOST_POSITION.x-1.0;
   }
   if (PLAYER_POSITION.y >= GHOST_POSITION.y) {
      GHOST_POSITION.y = GHOST_POSITION.y+1.0;
   }
   else {
      GHOST_POSITION.y = GHOST_POSITION.y-1.0;
   }
}

// TODO: add some other color to the ghost to make it stand out.
proc draw_ghost(camera_offset_x: f64, camera_offset_y: f64) {
   rect((GHOST_POSITION.x - camera_offset_x) truncate i32, (GHOST_POSITION.y - camera_offset_y) truncate i32, GHOST_WIDTH, GHOST_HEIGHT);
}

proc game_over() {
   let tmp = *DRAW_COLORS;
   *DRAW_COLORS = 0b0010000101000011; // use the 3rd palette color as the first draw color, etc. 0b0010_0001_0100_0011
   text("YOU LOST :(", 5, 30);
   *DRAW_COLORS = tmp;
}

proc maybe_play_game_over_noise() {
   if (!GAME_OVER) {
     let starting_freq: u32 = 590;
     let ending_freq: u32 = 110;
     tone(starting_freq| (ending_freq << 16), 60, DEFAULT_VOLUME, TONE_PULSE1 | TONE_MODE3);
   }
}
